<!doctype html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Gyro Demo</title>
	<link rel ="stylesheet" href="css/styles.css">
  </head>
  <body>
    alpha:<span id="alpha"></span><br>
    beta:<span id="beta"></span><br>
    gamma:<span id="gamma"></span><br>
	<canvas id="myCanvas" ></canvas> 
	<script>

	//get orientation info
	if (window.DeviceOrientationEvent) 
	{
		window.addEventListener("deviceorientation", function () 
		{
			processGyro(event.alpha, event.beta, event.gamma);  
		}, true);
	} 

    var deviceOrientationData ={alpha:0,beta:0,gamma:0};//init with 0 as defaults

	function processGyro(alpha,beta,gamma)
	{
        deviceOrientationData.alpha=alpha;
        deviceOrientationData.beta=beta;
        deviceOrientationData.gamma=gamma;

		document.getElementById("alpha").innerHTML=alpha;
		document.getElementById("beta").innerHTML=beta;
		document.getElementById("gamma").innerHTML =gamma;
	}
	var canvas = document.getElementById('myCanvas');
	var context = canvas.getContext('2d');
	context.canvas.width  = window.innerWidth;//resize canvas to whatever window dimensions are
	context.canvas.height = window.innerHeight;
	context.translate(canvas.width / 2, canvas.height / 2); //put 0,0,0 origin at center of screen instead of upper left corner

	function makeRect(width,height,depth)
	{
	var newObj={};
	var hw=width/2;
	var hh=height/2;
	var hd=depth/2;
	newObj.vertices=[  [-hw,hh,hd],[hw,hh,hd],[hw,-hh,hd],//first triangle
		  [-hw,hh,hd],[-hw,-hh,hd],[hw,-hh,hd],//2 triangles make front side
		  [-hw,hh,-hd],[-hw,hh,hd],[-hw,-hh,-hd], //left side
		  [-hw,hh,hd],[-hw,-hh,hd],[-hw,-hh,-hd],
		  [hw,hh,-hd],[hw,hh,hd],[hw,-hh,-hd], //right side
		  [hw,hh,hd],[hw,-hh,hd],[hw,-hh,-hd],
		  [-hw,hh,-hd],[hw,hh,-hd],[hw,-hh,-hd],//back
		  [-hw,hh,-hd],[-hw,-hh,-hd],[hw,-hh,-hd],
		  [-hw,hh,-hd],[hw,hh,-hd],[hw,hh,hd],//top
		  [-hw,hh,-hd],[-hw,hh,hd],[hw,hh,hd],
		  [-hw,-hh,-hd],[hw,-hh,-hd],[hw,-hh,hd],//bottom
		  [-hw,-hh,-hd],[-hw,-hh,hd],[hw,-hh,hd]
	];
	
	return newObj;
	}

	var cube=makeRect(canvas.width/5,canvas.width/5,canvas.width/5);
	cube.color="purple";
	var xAxis=makeRect(440,10,10);
	xAxis.color="green";
	var yAxis=makeRect(10,440,10);
	yAxis.color="red";
	var zAxis=makeRect(10,10,440);
	zAxis.color="blue";
	//render loop
	function renderLoop() 
	{
		if(!( window.DeviceOrientationEvent && 'ontouchstart' in window))//only happens on desktops
	  	{
			this.fakeAlpha = (this.fakeAlpha || 0)+ .0;//z axis – use 0 to turn off rotation
			this.fakeBeta = (this.fakeBeta || 0)+ .7;//x axis
			this.fakeGamma = (this.fakeGamma || 0)+ .5;//y axis
			processGyro(this.fakeAlpha,this.fakeBeta,this.fakeGamma); //fake gyro update event with canned data
	  	}
	  	requestAnimationFrame( renderLoop );//better than set interval as it pauses when browser isn’t active
	  	context.clearRect( -canvas.width/2, -canvas.height/2, canvas.width, canvas.height);//clear screen x, y, width, height
	  	renderObj(cube);
  		renderObj(xAxis);
  		renderObj(yAxis);
  		renderObj(zAxis);	
	}
	renderLoop();
    function renderObj(obj)//renders an object as a series of triangles
    {
        var rotatedObj=rotateObject(obj);
        context.lineWidth = 1;
        context.strokeStyle = obj.color;
        for(var i=0 ; i<obj.vertices.length ; i+=3)
        {
            for (var k=0;k<3;k++)
            {
			var vertexFrom=rotatedObj.vertices[i+k];         
            var temp=i+k+1;
            if(k==2) 
            temp=i;
			var vertexTo=rotatedObj.vertices[temp];
            context.beginPath();
            context.moveTo(vertexFrom[0], -vertexFrom[1]);
            context.lineTo(vertexTo[0], -vertexTo[1]);
            context.stroke();
            }
        }
    }
	function rotateObject(obj) //rotates obeject
	{
    	var newObj={};
    	newObj.vertices=[];
    	for(var i=0 ; i<obj.vertices.length ; i++)
    	{
      		newObj.vertices.push(rotatePointViaGyroEulars(obj.vertices[i]));
    	}
    	return newObj;
	}    
	function rotatePointViaGyroEulars(ra) //rotates 3d point based on euler angles
	{
		var oldX=ra[0];
		var oldY=ra[1];
		var oldZ=ra[2];
		
		//order here is important – it must match the processing order of the device
		
		//rotate about z axis
		var newX = oldX * Math.cos(-degToRad(deviceOrientationData.alpha)) - oldY * Math.sin(-degToRad(deviceOrientationData.alpha));
		var newY = oldY * Math.cos(-degToRad(deviceOrientationData.alpha)) + oldX * Math.sin(-degToRad(deviceOrientationData.alpha));
		
		//rotate about x axis
		oldY=newY;
		newY = oldY * Math.cos(-degToRad(deviceOrientationData.beta)) - oldZ * Math.sin(-degToRad(deviceOrientationData.beta));
		var newZ = oldZ * Math.cos(-degToRad(deviceOrientationData.beta)) + oldY * Math.sin(-degToRad(deviceOrientationData.beta));

		
		//rotate about y axis
		oldZ=newZ;
		oldX=newX;

		newZ = oldZ * Math.cos(-degToRad(deviceOrientationData.gamma)) - oldX * Math.sin(-degToRad(deviceOrientationData.gamma));
		newX = oldX * Math.cos(-degToRad(deviceOrientationData.gamma)) + oldZ * Math.sin(-degToRad(deviceOrientationData.gamma));

		
		return [newX,newY,newZ];
	}
	function degToRad(deg)// Degree-to-Radian conversion
	{
		 return deg * Math.PI / 180; 
	}

	</script>
</body>
</html>

